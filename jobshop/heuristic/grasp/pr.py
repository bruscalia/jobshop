import numpy as np
from math import ceil
from jobshop.params import JobShopParams
from jobshop.heuristic.operations import Graph
from jobshop.heuristic.grasp.base import GRASP
from jobshop.heuristic.path_relinking import PathRelinking
from jobshop.heuristic.grasp.pool import Pool


class GRASPPR(GRASP):
    
    def __init__(
        self,
        params: JobShopParams,
        alpha=(0.0, 1.0),
        init_iter=10000,
        maxpool=20,
        ifreq=10000,
        min_diff=0.25,
        mixed_construction=True,
        post_opt=True,
        seed=None,
    ) -> None:
        """GRASP with Path Relinking algorithm for the Job-shop scheduling problem

        Parameters
        ----------
        params : JobShopParams
            Problem parameters
        
        alpha : tuple | float, optional
            Greediness factor of constructive heuristics, by default (0.0, 1.0)
        
        init_iter : int, optional
            Number of iterations to compare new candidate purely with worst from pool.
            After that, new candidates are compared to the mean - 2 std solutions generated by GRASP (pure).
            By default 10000
        
        maxpool : int, optional
            Elite pool size, by default 20
        
        ifreq : int, optional
            Intensification heuristics frequency, by default 10000
        
        min_diff : float, optional
            Relative difference between elements of pool solutiions, by default 0.25
        
        mixed_construction : bool, optional
            Either of not to alternate between greedy construction by makespan (main)
            and greedy construction by time-remaining job (auxiliary), by default True
        
        post_opt : bool, optional
            Either or not to apply intensification after maxiter, by default True
        
        seed : int | None, optional
            numpy random seed, by default None
        """
        
        super().__init__(params, alpha, mixed_construction, seed)
        
        # Initialize other attributes
        self.path_relinking = PathRelinking(seed=seed)
        self.init_iter = init_iter
        min_delta = ceil(min_diff * len(params.machines) * len(params.jobs))
        self.pool = Pool(min_delta=min_delta)
        self.maxpool = maxpool
        self.ifreq = ifreq
        self.post_opt = post_opt
        self.seed = seed
        
        # Initialize seed and solutions pool
        self.grasp_solutions = []
    
    def __call__(self, maxiter=10000, target=None, verbose=False, seed=None, **kwargs) -> Graph:
        
        # Set self attributes from kwargs
        for key, value in kwargs.items():
            setattr(self, key, value)
        
        # Random seed
        if seed is None:
            np.random.seed(self.seed)
        else:
            np.random.seed(seed)
        
        # Target
        if target is None:
            target = -float("inf")
        
        # Initialize
        last_int_pool = self.pool.P.copy()
        i = 0
        
        # Iterate using solution generator
        for S in self.iter(maxiter):
            
            # Add new solution
            self.grasp_solutions.append(S.C)
            
            # If pool is full
            if len(self.pool.P) == self.maxpool:
            
                # Verify quality
                if self.verify_quality(S):
                    self.two_sided_pr(S, target=target, verbose=verbose)
                    if self.check_termination(target):
                        return self.pool.P[0]
            
            # Else just add to pool
            else:
                self.pool.append(S, verbose=verbose)
                if self.check_termination(target):
                    return self.pool.P[0]
            
            # Do instensification
            if (i % self.ifreq == 0) and (len(self.pool.P) >= 2):
                self.intensification(target=target, verbose=verbose)
                if self.check_termination(target):
                    return self.pool.P[0]
                
                # Assign half the pool to inf
                if np.array_equiv(last_int_pool, self.pool.P) and (i > self.ifreq):
                    self.pool.C[-self.last_half:] = float("inf")
                    if verbose:
                        print("Assign half the pool inf values")
                        print(f"New pool: {self.pool.C}")
                
                # Update last pool
                last_int_pool = self.pool.P.copy()
            
            # Update iter
            i = i + 1
        
        # Do post optimization
        if self.post_opt:
            if verbose:
                    print("Post optimization")
            self.intensification(target=target, verbose=verbose)
        
        return self.pool.P[0] 
    
    def verify_quality(self, S):
        if self.past_iterations <= self.init_iter:
            accepted = S.C <= self.pool.C[-1]
        else:
            lim = max(self.pool.C[-1], np.mean(self.grasp_solutions) - 2 * np.std(self.grasp_solutions))
            accepted = S.C <= lim
        return accepted
    
    def two_sided_pr(self, S, target=-float("inf"), verbose=False):
        for T in self.pool.P:
            S_gmin = self.path_relinking(S, T, min_delta=2)
            self.pool.update(S_gmin, verbose=verbose)
            if self.check_termination(target):
                return
            S_gmin = self.path_relinking(T, S, min_delta=2)
            self.pool.update(S_gmin, verbose=verbose)
            if self.check_termination(target):
                return
    
    def intensification(self, target=-float("inf"), verbose=False):
        if verbose:
            print("Starting intensification")
        
        # Create a set of elite solutions not yet evaluated
        Q = set(self.pool.P.copy())
        
        # Do path relinking from S to every other in Pool
        while len(Q) > 0:
            S = Q.pop()
            for T in self.pool.P:
                S_gmin = self.path_relinking(S, T, min_delta=2)
                self.pool.update(S_gmin, verbose=verbose)

                # S_gmin as a copy is considered different from S
                if S_gmin in self.pool.P:
                    if verbose:
                        print(f"New solution to Q: {S_gmin.C}")
                    Q.add(S_gmin)
                
                # Break if target is met
                if self.check_termination(target):
                    return
        if verbose:
            print("Finished intensification")
    
    def check_termination(self, target):
        return self.pool.C[0] <= target
    
    @property
    def last_half(self):
        return self.maxpool // 2
    
    @property
    def past_iterations(self):
        return len(self.grasp_solutions)